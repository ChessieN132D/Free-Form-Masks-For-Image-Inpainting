# -*- coding: utf-8 -*-
"""Resize Dataset of Image Inpainting

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a9CBD4jSyHpk1UAbwvQIcLC1IIir4M9g
"""

# Imports
import requests
import pandas as pd
import io
from io import BytesIO
import matplotlib.pyplot as plt
import os
from torchvision.datasets import ImageFolder
from torchvision.transforms import CenterCrop


import numpy as np
import random
import math
from PIL import Image, ImageDraw


# Create the mask

np.random.seed(37)

# Create the mask
def mask(im_height, im_width):
    
    mask = Image.new('L', (im_width, im_height), 0)
    draw = ImageDraw.Draw(mask)

    # Create each serpent of vertexes in the mask
    for serpent_id in range(random.randint(1, 5)):
        vertex_num = random.randint(1, 7)
        x_start = random.randint(0, im_width)
        y_start = random.randint(0, im_height)
        vertex_position = [(x_start, y_start)]

        # Create each vertex line in the serpent with a series of overlapping
        # round ellipses
        for i in range(vertex_num):
            start_point = (vertex_position[-1][0], vertex_position[-1][1])     
            angle = random.uniform(0.0, 2.0)*math.pi
            vertex_length = random.randint(10, 50)
            end_point = ((start_point[0]+vertex_length*math.cos(angle)), 
                         (start_point[1]+vertex_length*math.sin(angle)))
            vertex_position.append(end_point)
            ellipse_num = random.randint(75,150)

            # Create ellipse with radius large enough so that they overlap
            ellipse_radius = 6*vertex_length/ellipse_num

            # Create the series of ellipse on the vertex line 
            for ell in range(ellipse_num):
                new_x = start_point[0]+ell*(end_point[0]-start_point[0])/ellipse_num
                new_y = start_point[1]+ell*(end_point[1]-start_point[1])/ellipse_num
                draw.ellipse([new_x-ellipse_radius, new_y-ellipse_radius,
                                   new_x+ellipse_radius, new_y+ellipse_radius], 
                                  fill=255, outline=255, width=1)

    return mask

mask(128,128)

mask(128,128)

mask(128,128)

completed_processing = set()

source_dir = '/content/drive/MyDrive/MIE1517 _Project/dataset/'
output_dir = '/content/drive/MyDrive/MIE1517 _Project/processed_dataset/'

i = 0

nb_excluded = 0

import time

start = time.time()

with os.scandir(source_dir) as it:
  for item in it:
    i+=1
    if item.name.endswith('.jpg'):
      if item.name in completed_processing:
        continue
      
      completed_processing.add(item.name)

      with Image.open(source_dir + item.name) as image:

        width, height = image.size
        if width<128 or height<128:
          nb_excluded += 1
          continue
        
        crop_img = CenterCrop(128)(image)
        crop_img.save(output_dir + item.name)
    
    if i%50 == 0:
      print(i)

end = time.time()
print(end - start)
print(nb_excluded)
print(i)














img_filename = os.listdir('/content/drive/MyDrive/MIE1517 _Project/dataset')

# Upload the dataset from the folder dataset
img_dataset_2 = ImageFolder('/content/drive/MyDrive/MIE1517 _Project/dataset')

print(len(img_dataset_2))

# Before cropping to 128, we need to ensure that there is no dimension less than
# 128 in the dataset.
# Scan the dataset for the dimensions smaller or equal to 128 pixels.

drop_index = []
for i in range(len(img_dataset_2)):
    image = img_dataset_2[i]
    width, height = image.size
    if width<=128 or height<-128:
        drop_index.append(i)

np.delete(img_dataset_2, drop_index)

print(len(img_dataset_2))

# Creation of the datasets to be transformed.
cropping_data = img_dataset_2
img_cropped = []

# Cropping the images
for i in range(len(cropping_data)):
    crop_img = transforms.CenterCrop(128)(cropping_data[i])
    img_cropped.append(crop_img)

plt.imshow(img_cropped[300])
plt.title('128x128 Cropped Image')
plt.show()

# Save the dataset of cropped images to the